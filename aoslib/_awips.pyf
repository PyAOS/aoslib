!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _awips ! in 
    interface  ! in :_aoslib
        
        subroutine add_aray(a,b,result,mni,ni,nj,mode) ! in :_aoslib:addaray.f
            real dimension(mni,nj), intent(in) :: a
            real dimension(mni,nj), intent(in) :: b
            real dimension(mni,nj), intent(out) :: result
            integer, intent(hide), depend(a) :: mni=shape(a,0)
            integer, optional, check(ni<=shape(a,0)) :: ni=shape(a,0)
            integer, intent(hide), depend(a) :: nj=shape(a,1)
            integer, optional :: mode=0
        end subroutine add_aray
        
        subroutine dgeocomps(z,f,spax,spay,mnx,mny,nx,ny,dugdx,dugdy,dvgdx,dvgdy) ! in :_aoslib:dgeocomps.f
            real*4 dimension(mnx,mny) :: z
            real*4 dimension(mnx,mny),depend(mnx,mny) :: f
            real*4 dimension(mnx,mny),depend(mnx,mny) :: spax
            real*4 dimension(mnx,mny),depend(mnx,mny) :: spay
            integer*4, optional,check(shape(z,0)==mnx),depend(z) :: mnx=shape(z,0)
            integer*4, optional,check(shape(z,1)==mny),depend(z) :: mny=shape(z,1)
            integer*4 :: nx
            integer*4 :: ny
            real*4 dimension(mnx,mny),depend(mnx,mny) :: dugdx
            real*4 dimension(mnx,mny),depend(mnx,mny) :: dugdy
            real*4 dimension(mnx,mny),depend(mnx,mny) :: dvgdx
            real*4 dimension(mnx,mny),depend(mnx,mny) :: dvgdy
        end subroutine dgeocomps
        subroutine meanomega(p1,u1,v1,p2,u2,v2,dx,dy,dt,work,omega,mnx,nx,ny) ! in :_aoslib:meanomega.f
            real*4 dimension(mnx,ny) :: p1
            real*4 dimension(mnx,ny),depend(mnx,ny) :: u1
            real*4 dimension(mnx,ny),depend(mnx,ny) :: v1
            real*4 dimension(mnx,ny),depend(mnx,ny) :: p2
            real*4 dimension(mnx,ny),depend(mnx,ny) :: u2
            real*4 dimension(mnx,ny),depend(mnx,ny) :: v2
            real*4 dimension(mnx,ny),depend(mnx,ny) :: dx
            real*4 dimension(mnx,ny),depend(mnx,ny) :: dy
            real*4 :: dt
            real*4 dimension(mnx,ny),depend(mnx,ny) :: work
            real*4 dimension(mnx,ny),depend(mnx,ny) :: omega
            integer*4, optional,check(shape(p1,0)==mnx),depend(p1) :: mnx=shape(p1,0)
            integer*4 :: nx
            integer*4, optional,check(shape(p1,1)==ny),depend(p1) :: ny=shape(p1,1)
        end subroutine meanomega
        subroutine smooth(input,output,mnx,ix,iy,smth) ! in :_aoslib:smooth.f
            real dimension(mnx,iy) :: input
            real dimension(mnx,iy),depend(mnx,iy) :: output
            integer, optional,check(shape(input,0)==mnx),depend(input) :: mnx=shape(input,0)
            integer :: ix
            integer, optional,check(shape(input,1)==iy),depend(input) :: iy=shape(input,1)
            real :: smth
        end subroutine smooth
        subroutine add_by_cnst(a,const_bn,result,mni,ni,nj) ! in :_aoslib:addbycnst.f
            real dimension(mni,nj) :: a
            real :: const_bn
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine add_by_cnst
        subroutine div_aray(a,b,result,mni,ni,nj) ! in :_aoslib:divaray.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine div_aray
        subroutine mixrat(p,t,rh,mni,ni,nj,q) ! in mixrat.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in)  :: rh
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out) :: q
        end subroutine mixrat
        subroutine alt2press(alt,z,mni,ni,nj,p) ! in :_aoslib:alt2press.f
            real dimension(mni,nj), intent(in) :: alt
            real dimension(mni,nj), intent(in) :: z
            integer intent(hide), depend(alt) :: mni=shape(alt,0)
            integer optional, check(ni<=shape(alt,0)) :: ni=shape(alt,0)
            integer intent(hide), depend(alt) :: nj=shape(alt,1)
            real dimension(mni,nj),intent(out),depend(mni,nj) :: p
        end subroutine alt2press
        function dmixr(temp,pres,iw) ! in :_aoslib:dmixr.f
            real intent(in) :: temp
            real intent(in) :: pres
            integer intent(in) :: iw
            real intent(out) :: dmixr
        end function dmixr
        subroutine mslp2thkns(mslp,hgt,thkns,mni,ni,nj) ! in mslp2thkns.f
            real*4 dimension(mni,nj), intent(in) :: mslp
            real*4 dimension(mni,nj), intent(in) :: hgt
            real*4 dimension(mni,nj), intent(out) :: thkns
            integer intent(hide), depend(mslp) :: mni=shape(mslp,0)
            integer optional, check(ni<=shape(mslp,0)) :: ni=shape(mslp,0)
            integer intent(hide), depend(mslp) :: nj=shape(mslp,1)
        end subroutine mslp2thkns
        subroutine spechum2(p,td,mni,ni,nj,q) ! in spechum2.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: td
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out) :: q
        end subroutine spechum2
        subroutine avwind(elev,top,bot,hw,pw,tw,uw,vw,nw,uavg,vavg,avdir,avspd) ! in :_aoslib:avwind.f
            real :: elev
            real :: top
            real :: bot
            real dimension(nw) :: hw
            real dimension(nw),depend(nw) :: pw
            real dimension(nw),depend(nw) :: tw
            real dimension(nw),depend(nw) :: uw
            real dimension(nw),depend(nw) :: vw
            integer, optional,check(len(hw)>=nw),depend(hw) :: nw=len(hw)
            real :: uavg
            real :: vavg
            real :: avdir
            real :: avspd
        end subroutine avwind
        subroutine dotvectors(ax,ay,bx,by,result,mni,ni,nj) ! in :_aoslib:dotvectors.f
            real dimension(mni,nj) :: ax
            real dimension(mni,nj),depend(mni,nj) :: ay
            real dimension(mni,nj),depend(mni,nj) :: bx
            real dimension(mni,nj),depend(mni,nj) :: by
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(ax,0)==mni),depend(ax) :: mni=shape(ax,0)
            integer :: ni
            integer, optional,check(shape(ax,1)==nj),depend(ax) :: nj=shape(ax,1)
        end subroutine dotvectors
        subroutine mult_aray(a,b,result,mni,ni,nj) ! in :_aoslib:multaray.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine mult_aray
        subroutine spechum(p,t,rh,mni,ni,nj,q) ! in spechum.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj), intent(out) :: q
        end subroutine spechum
        subroutine richno(ht,hw,uw,vw,rho,nlvls,nw,buoy,richnum) ! in :_aoslib:BulkRichNo.f
            real dimension(nlvls) :: ht
            real dimension(nw) :: hw
            real dimension(nw),depend(nw) :: uw
            real dimension(nw),depend(nw) :: vw
            real dimension(nlvls),depend(nlvls) :: rho
            integer, optional,check(len(ht)>=nlvls),depend(ht) :: nlvls=len(ht)
            integer, optional,check(len(hw)>=nw),depend(hw) :: nw=len(hw)
            real :: buoy
            real :: richnum
        end subroutine richno
        function dzdlnp(p,t,td) ! in :_aoslib:dzdlnp.f
            real*4 intent(in) :: p
            real*4 intent(in) :: t
            real*4 intent(in) :: td
            real*4 intent(out) :: dzdlnp
        end function dzdlnp
        subroutine mult_by_cnst(a,const_bn,result,mni,ni,nj) ! in :_aoslib:multbycnst.f
            real dimension(mni,nj) :: a
            real :: const_bn
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine mult_by_cnst
        subroutine sub_aray(a,b,result,mni,ni,nj) ! in :_aoslib:subaray.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine sub_aray
        subroutine calccondprdef(p,t,rh,mni,ni,nj,q) ! in :_aoslib:calccondprdef.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer, intent(hide), depend(p)  :: mni=shape(p,0)
            integer optional, check(ni <= shape(p,0)) :: ni=shape(p,0)
            integer, intent(hide), depend(p) ::  nj=shape(p,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: q
        end subroutine calccondprdef
        subroutine eqlev(p,ht,tp,te,plfc,eptpar,npar,peqlev,heqlev,teqlev) ! in :_aoslib:eqlev.f
            real dimension(npar) :: p
            real dimension(npar),depend(npar) :: ht
            real dimension(npar),depend(npar) :: tp
            real dimension(npar),depend(npar) :: te
            real :: plfc
            real :: eptpar
            integer, optional,check(len(p)>=npar),depend(p) :: npar=len(p)
            real :: peqlev
            real :: heqlev
            real :: teqlev
        end subroutine eqlev
        function radnorm(jd) ! in sunfuncs.f
            integer intent(in) :: jd
            real intent(out) :: radnorm
        end function radnorm
        function soldec(jd) ! in sunfuncs.f
            integer intent(in) :: jd
            real intent(out) :: soldec
        end function soldec
        function timeq(jd) ! in sunfuncs.f
            integer intent(in) :: jd
            real intent(out) :: timeq
        end function timeq
        subroutine calccondpr(p,t,rh,mni,ni,nj,q) ! in calccondpr.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer, intent(hide), depend(p)  :: mni=shape(p,0)
            integer optional, check(ni <= shape(p,0)) :: ni=shape(p,0)
            integer, intent(hide), depend(p) ::  nj=shape(p,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: q
        end subroutine calccondpr
        subroutine eqp(deltap,p,ht,t,td,n,pp,htt,tt,ttd,nn) ! in :_aoslib:eqp.f
            real :: deltap
            real dimension(1) :: p
            real dimension(1) :: ht
            real dimension(1) :: t
            real dimension(1) :: td
            integer :: n
            real dimension(1) :: pp
            real dimension(1) :: htt
            real dimension(1) :: tt
            real dimension(1) :: ttd
            integer :: nn
        end subroutine eqp
        subroutine nadgdt(u,v,a,mni,ni,nj,dx,dy,dadxdt,dadydt) ! in nadgdt.f
            real dimension(mni,nj), :: u
            real dimension(mni,nj),depend(mni,nj) :: v
            real dimension(mni,nj),depend(mni,nj) :: a
            integer, optional,check(shape(u,0)==mni),depend(u) :: mni=shape(u,0)
            integer :: ni
            integer, optional,check(shape(u,1)==nj),depend(u) :: nj=shape(u,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: dadxdt
            real dimension(mni,nj),depend(mni,nj) :: dadydt
        end subroutine nadgdt
        subroutine sweat(p,t,td,nlvls,pw,uw,vw,nw,swidx) ! in :_aoslib:sweat.f
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: t
            real dimension(nlvls),depend(nlvls) :: td
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            real dimension(nw) :: pw
            real dimension(nw),depend(nw) :: uw
            real dimension(nw),depend(nw) :: vw
            integer, optional,check(len(pw)>=nw),depend(pw) :: nw=len(pw)
            real :: swidx
        end subroutine sweat
        subroutine calcdpd(t,rh,mni,ni,nj,dpd) ! in calcdpd.f
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj),intent(out), depend(mni,nj) :: dpd
        end subroutine calcdpd
        function esat(t) ! in esat.f
            real*4 intent(in) :: t
            real*4 intent(out) :: esat
        end function esat
        subroutine natlog(a,b,mni,ni,nj) ! in :_aoslib:natlog.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine natlog
        subroutine sweatidx(tt,td8,u8,v8,u5,v5,mni,ni,nj,q) ! in :_aoslib:sweatidx.f
            real dimension(mni,nj) :: tt
            real dimension(mni,nj),depend(mni,nj) :: td8
            real dimension(mni,nj),depend(mni,nj) :: u8
            real dimension(mni,nj),depend(mni,nj) :: v8
            real dimension(mni,nj),depend(mni,nj) :: u5
            real dimension(mni,nj),depend(mni,nj) :: v5
            integer, optional,check(shape(tt,0)==mni),depend(tt) :: mni=shape(tt,0)
            integer :: ni
            integer, optional,check(shape(tt,1)==nj),depend(tt) :: nj=shape(tt,1)
            real dimension(mni,nj),depend(mni,nj) :: q
        end subroutine sweatidx
        subroutine calcli(p,t,rh,t5,p5,mni,ni,nj,li) ! in calcli.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            real dimension(mni,nj), intent(in) :: t5
            real optional :: p5 = 500
            integer, intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer,intent(hide),depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: li
        end subroutine calcli
        subroutine exp_aray(a,b,mni,ni,nj) ! in :_aoslib:exparay.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine exp_aray
        subroutine negarea(pcb,tcb,hcb,plfc,hlfc,tlfc,thdpar,eptpar,p,ht,te,tp,npar,cinfrmcape,negbuoy) ! in :_aoslib:negarea.f
            real :: pcb
            real :: tcb
            real :: hcb
            real :: plfc
            real :: hlfc
            real :: tlfc
            real :: thdpar
            real :: eptpar
            real dimension(npar) :: p
            real dimension(npar),depend(npar) :: ht
            real dimension(npar),depend(npar) :: te
            real dimension(npar),depend(npar) :: tp
            integer, optional,check(len(p)>=npar),depend(p) :: npar=len(p)
            real :: cinfrmcape
            real :: negbuoy
        end subroutine negarea
        function tdofesat(es) ! in tdofesat.f
            real*4 intent(in) :: es
            real*4 intent(out) :: tdofesat
        end function tdofesat
        subroutine calcpv(p_up,p_low,o_up,o_low,pvort,mni,ni,nj,u_up,v_up,u_low,v_low,avort1,avort2,dx,dy,coriolis) ! calcpv.f
            real*4 dimension(mni,nj), intent(in) :: p_up
            real*4 dimension(mni,nj), intent(in) :: p_low
            real intent(in) :: o_up
            real intent(in) :: o_low
            real*4 dimension(mni,nj), intent(out), depend(mni,nj) :: pvort
            integer intent(hide), depend(p_up) :: mni=shape(p_up,0)
            integer optional, check(ni<=shape(p_up,0)) :: ni=shape(p_up,0)
            integer intent(hide), depend(p_up) :: nj=shape(p_up,1)
            real dimension(mni,nj), intent(in) :: u_up
            real dimension(mni,nj), intent(in) :: v_up
            real dimension(mni,nj), intent(in) :: u_low
            real dimension(mni,nj), intent(in) :: v_low
            real dimension(mni,nj), intent(hide), depend(mni,nj) :: avort1
            real dimension(mni,nj), intent(hide), depend(mni,nj) :: avort2
            real dimension(mni,nj), intent(in) :: dx
            real dimension(mni,nj), intent(in) :: dy
            real dimension(mni,nj), intent(in) :: coriolis
        end subroutine calcpv
        subroutine fndiverg(zmid,ztop,zbot,ptop,pbot,mni,ni,nj,dx,dy,f,fnx,fny,w1,dtdx,dtdy,qx,qy,fndiv) ! in :_aoslib:fndiverg.f
            real dimension(mni,nj) :: zmid
            real dimension(mni,nj),depend(mni,nj) :: ztop
            real dimension(mni,nj),depend(mni,nj) :: zbot
            real :: ptop
            real :: pbot
            integer, optional,check(shape(zmid,0)==mni),depend(zmid) :: mni=shape(zmid,0)
            integer :: ni
            integer, optional,check(shape(zmid,1)==nj),depend(zmid) :: nj=shape(zmid,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: f
            real dimension(mni,nj),depend(mni,nj) :: fnx
            real dimension(mni,nj),depend(mni,nj) :: fny
            real dimension(mni,nj),depend(mni,nj) :: w1
            real dimension(mni,nj),depend(mni,nj) :: dtdx
            real dimension(mni,nj),depend(mni,nj) :: dtdy
            real dimension(mni,nj),depend(mni,nj) :: qx
            real dimension(mni,nj),depend(mni,nj) :: qy
            real dimension(mni,nj),depend(mni,nj) :: fndiv
        end subroutine fndiverg
        subroutine temp2theta(p,aflgp,t,aflgt,theta,mnx,nx,ny) ! in :_aoslib:temp2theta.f
            real*4 dimension(mnx,ny) :: p
            integer*4 :: aflgp
            real*4 dimension(mnx,ny),depend(mnx,ny) :: t
            integer*4 :: aflgt
            real*4 dimension(mnx,ny),depend(mnx,ny) :: theta
            integer*4, optional,check(shape(p,0)==mnx),depend(p) :: mnx=shape(p,0)
            integer*4 :: nx
            integer*4, optional,check(shape(p,1)==ny),depend(p) :: ny=shape(p,1)
        end subroutine temp2theta
        subroutine calcrh2(p,t,q,mni,ni,nj,rh) ! in calcrh2.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: q
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj),intent(out), depend(mni,nj) :: rh
        end subroutine calcrh2
        subroutine posarea(plfc,peqlev,tlfc,teqlev,hlfc,heqlev,eptpar,p,ht,te,tp,npar,buoy,cin) ! in :_aoslib:posarea.f
            real :: plfc
            real :: peqlev
            real :: tlfc
            real :: teqlev
            real :: hlfc
            real :: heqlev
            real :: eptpar
            real dimension(npar) :: p
            real dimension(npar),depend(npar) :: ht
            real dimension(npar),depend(npar) :: te
            real dimension(npar),depend(npar) :: tp
            integer, optional,check(len(p)>=npar),depend(p) :: npar=len(p)
            real :: buoy
            real :: cin
        end subroutine posarea
        subroutine theta2temp(p,aflgp,theta,aflgth,t,mnx,nx,ny) ! in :_aoslib:theta2temp.f
            real*4 dimension(mnx,ny) :: p
            integer*4 :: aflgp
            real*4 dimension(mnx,ny),depend(mnx,ny) :: theta
            integer*4 :: aflgth
            real*4 dimension(mnx,ny),depend(mnx,ny) :: t
            integer*4, optional,check(shape(p,0)==mnx),depend(p) :: mnx=shape(p,0)
            integer*4 :: nx
            integer*4, optional,check(shape(p,1)==ny),depend(p) :: ny=shape(p,1)
        end subroutine theta2temp
        subroutine calcrh(t,td,mni,ni,nj,rh) ! in calcrh.f
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: td
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj),intent(out),depend(mni,nj) :: rh
        end subroutine calcrh
        subroutine fortconbuf(array,work,mnx,nx,ny,scale,offset,mode,seed,xpoints,ypoints,npoints,badlo,badhi,status) ! in :_aoslib:fortconbuf.f
            real*4 dimension(mnx,*) :: array
            byte dimension(nx,ny,4) :: work
            integer*4, optional,check(shape(array,0)==mnx),depend(array) :: mnx=shape(array,0)
            integer*4, optional,check(shape(work,0)==nx),depend(work) :: nx=shape(work,0)
            integer*4, optional,check(shape(work,1)==ny),depend(work) :: ny=shape(work,1)
            real*4 :: scale
            real*4 :: offset
            integer*4 :: mode
            real*4 dimension(*) :: seed
            real*4 dimension(*) :: xpoints
            real*4 dimension(*) :: ypoints
            integer*4 :: npoints
            real*4 :: badlo
            real*4 :: badhi
            integer*4 :: status
            integer*4 :: celcnt
            integer*4 :: labsep
            integer*4 :: dlx
            integer*4 :: dld
            integer*4 :: dly
            integer*4 :: c
            integer*4 :: labsep2
            integer*4 dimension(200) :: patern
            character dimension(200,7) :: labstr
            integer*4 dimension(200) :: chrn
            real*4 dimension(200) :: conval
            real*4 dimension(200) :: convals
            real*4 dimension(200) :: mxavg
            real*4 dimension(200) :: mnavg
            byte, optional,dimension(200) :: cmask=1
            common /connewcmnbuf/ celcnt,labsep,dlx,dld,dly,c,labsep2,patern,labstr,chrn,conval,convals,mxavg,mnavg,cmask
        end subroutine fortconbuf
        subroutine contr1_b(istart,jstart,sstart,dat,work,mnx,nx,ny,xpoints,ypoints,npoints) ! in :_aoslib:fortconbuf.f
            integer*4 :: istart
            integer*4 :: jstart
            integer*4 :: sstart
            real*4 dimension(mnx,*) :: dat
            byte dimension(nx,ny,4) :: work
            integer*4, optional,check(shape(dat,0)==mnx),depend(dat) :: mnx=shape(dat,0)
            integer*4, optional,check(shape(work,0)==nx),depend(work) :: nx=shape(work,0)
            integer*4, optional,check(shape(work,1)==ny),depend(work) :: ny=shape(work,1)
            real*4 dimension(*) :: xpoints
            real*4 dimension(*) :: ypoints
            integer*4 :: npoints
            integer*4, optional :: npasses=0
            real*4 :: wgt1
            integer*4 :: celcnt
            integer*4 :: labsep
            integer*4 :: dlx
            integer*4 :: dld
            integer*4 :: dly
            integer*4 :: c
            integer*4 :: labsep2
            integer*4 dimension(200) :: patern
            byte dimension(7,200) :: labstr
            integer*4 dimension(200) :: chrn
            real*4 dimension(200) :: conval
            real*4 dimension(200) :: convals
            real*4 dimension(200) :: mxavg
            real*4 dimension(200) :: mnavg
            byte dimension(200) :: cmask
            common /smoothcmnbuf/ npasses,wgt1
            common /connewcmnbuf/ celcnt,labsep,dlx,dld,dly,c,labsep2,patern,labstr,chrn,conval,convals,mxavg,mnavg,cmask
        end subroutine contr1_b
        subroutine smoothing_b(smoothness,npass) ! in :_aoslib:fortconbuf.f
            real*4 :: smoothness
            integer*4 :: npass
            integer*4 :: npasses
            real*4 :: wgt1
            common /smoothcmnbuf/ npasses,wgt1
        end subroutine smoothing_b
        subroutine zeroitoutbuf(work,nn) ! in :_aoslib:fortconbuf.f
            byte dimension(*) :: work
            integer*4 :: nn
        end subroutine zeroitoutbuf
        function pottemp(temp,dwpt,pres,iw) ! in pottemp.f
            real intent(in) :: temp
            real intent(in) :: dwpt
            real intent(in) :: pres
            integer intent(in) :: iw
            real intent(out) :: pottemp
        end function pottemp
        function thetawa(temp,dwpt,pres,iw,ier) ! in thetawa.f
            real intent(in) :: temp
            real intent(in) :: dwpt
            real intent(in) :: pres
            integer intent(in) :: iw
            integer intent(hide) :: ier
            real intent(out) :: thetawa
        end function thetawa
        subroutine calctd2(p,t,q,mni,ni,nj,td) ! in calctd2.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: q
            integer, intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer,intent(hide),depend(p) :: nj=shape(p,1)
            real dimension(mni,nj),intent(out), depend(mni,nj) :: td
        end subroutine calctd2
        subroutine frontogen(zmid,ztop,zbot,ptop,pbot,mni,ni,nj,dx,dy,f,w1,w2,w3,dtdx,dtdy,qx,qy,fgen) ! in :_aoslib:frontogen.f
            real dimension(mni,nj) :: zmid
            real dimension(mni,nj),depend(mni,nj) :: ztop
            real dimension(mni,nj),depend(mni,nj) :: zbot
            real :: ptop
            real :: pbot
            integer, optional,check(shape(zmid,0)==mni),depend(zmid) :: mni=shape(zmid,0)
            integer :: ni
            integer, optional,check(shape(zmid,1)==nj),depend(zmid) :: nj=shape(zmid,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: f
            real dimension(mni,nj),depend(mni,nj) :: w1
            real dimension(mni,nj),depend(mni,nj) :: w2
            real dimension(mni,nj),depend(mni,nj) :: w3
            real dimension(mni,nj),depend(mni,nj) :: dtdx
            real dimension(mni,nj),depend(mni,nj) :: dtdy
            real dimension(mni,nj),depend(mni,nj) :: qx
            real dimension(mni,nj),depend(mni,nj) :: qy
            real dimension(mni,nj),depend(mni,nj) :: fgen
        end subroutine frontogen
        subroutine powercalc(a,b,result,mni,ni,nj) ! in :_aoslib:powercalc.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine powercalc
        subroutine totals(p,t,td,nlvls,totidx,crstot,vertot) ! in :_aoslib:totals.f
            real dimension(1) :: p
            real dimension(1) :: t
            real dimension(1) :: td
            integer :: nlvls
            real :: totidx
            real :: crstot
            real :: vertot
        end subroutine totals
        
        subroutine calctd(t,rh,mni,ni,nj,td) ! in calctd.f
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            real dimension(mni,nj), intent(out), depend(mni, nj) :: td
        end subroutine calctd
        
        subroutine frzlev(elev,p,ht,t,nlvls,pfrz,hfrz) ! in :_aoslib:frzlev.f
            real :: elev
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: ht
            real dimension(nlvls),depend(nlvls) :: t
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            real :: pfrz
            real :: hfrz
        end subroutine frzlev
        subroutine press2alt(p,z,mni,ni,nj,alt) ! in press2alt.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: z
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out) :: alt
        end subroutine press2alt
        subroutine tplcl(tk,td,pinit,tl,pl,ier) ! in :_aoslib:tplcl.f
            real :: tk
            real :: td
            real :: pinit
            real :: tl
            real :: pl
            integer :: ier
        end subroutine tplcl
        subroutine calcthetae2(p,t,td,mni,ni,nj,q) ! in calcthetae2.f
            real dimension(mni,nj), intent(in)  :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: td
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: q
        end subroutine calcthetae2
        subroutine fsdiverg(zmid,ztop,zbot,ptop,pbot,mni,ni,nj,dx,dy,f,fsx,fsy,w1,dtdx,dtdy,qx,qy,fsdiv) ! in :_aoslib:fsdiverg.f
            real dimension(mni,nj) :: zmid
            real dimension(mni,nj),depend(mni,nj) :: ztop
            real dimension(mni,nj),depend(mni,nj) :: zbot
            real :: ptop
            real :: pbot
            integer, optional,check(shape(zmid,0)==mni),depend(zmid) :: mni=shape(zmid,0)
            integer :: ni
            integer, optional,check(shape(zmid,1)==nj),depend(zmid) :: nj=shape(zmid,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: f
            real dimension(mni,nj),depend(mni,nj) :: fsx
            real dimension(mni,nj),depend(mni,nj) :: fsy
            real dimension(mni,nj),depend(mni,nj) :: w1
            real dimension(mni,nj),depend(mni,nj) :: dtdx
            real dimension(mni,nj),depend(mni,nj) :: dtdy
            real dimension(mni,nj),depend(mni,nj) :: qx
            real dimension(mni,nj),depend(mni,nj) :: qy
            real dimension(mni,nj),depend(mni,nj) :: fsdiv
        end subroutine fsdiverg
        subroutine pres_stability(t_up,t_low,p_up,p_low,stab,mni,ni,nj) ! in :_aoslib:presstable.f
            real*4 dimension(mni,nj) :: t_up
            real*4 dimension(mni,nj),depend(mni,nj) :: t_low
            real :: p_up
            real :: p_low
            real*4 dimension(mni,nj),depend(mni,nj) :: stab
            integer, optional,check(shape(t_up,0)==mni),depend(t_up) :: mni=shape(t_up,0)
            integer :: ni
            integer, optional,check(shape(t_up,1)==nj),depend(t_up) :: nj=shape(t_up,1)
        end subroutine pres_stability
        subroutine tpzlcl(tk,tdk,pinit,iw,tl,pl,zl,ier) ! in :_aoslib:tpzlcl.f
            real :: tk
            real :: tdk
            real :: pinit
            integer :: iw
            real :: tl
            real :: pl
            real :: zl
            integer :: ier
        end subroutine tpzlcl
        subroutine calcthetae(p,t,rh,mni,ni,nj,q) ! in calcthetae.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: q
        end subroutine calcthetae
        subroutine g2gkinematics(udx,vdy,q,spax,spay,mnx,mny,nx,ny,choice,scalar) ! in :_aoslib:g2gkinematics.f
            real*4 dimension(mnx,mny) :: udx
            real*4 dimension(mnx,mny),depend(mnx,mny) :: vdy
            real*4 dimension(mnx,mny),depend(mnx,mny) :: q
            real*4 dimension(mnx,mny),depend(mnx,mny) :: spax
            real*4 dimension(mnx,mny),depend(mnx,mny) :: spay
            integer*4, optional,check(shape(udx,0)==mnx),depend(udx) :: mnx=shape(udx,0)
            integer*4, optional,check(shape(udx,1)==mny),depend(udx) :: mny=shape(udx,1)
            integer*4 :: nx
            integer*4 :: ny
            integer*4 :: choice
            real*4 dimension(mnx,mny),depend(mnx,mny) :: scalar
        end subroutine g2gkinematics
        subroutine pseudolift(n,pstart,pfinish,soln) ! in :_aoslib:pseudolift.f
            integer, optional,check((len(soln)-1)>=n),depend(soln) :: n=(len(soln)-1)
            real :: pstart
            real :: pfinish
            real dimension(n + 1) :: soln
        end subroutine pseudolift
        function pmalrrhs(p,tk) ! in :_aoslib:pseudolift.f
            real :: p
            real :: tk
            real*8 :: pmalrrhs
        end function pmalrrhs
        subroutine tsoar(elev,p,z,t,theta,nl,tpmax,ptlxec,zlnec,tlnec,zlxec,tlxec,soarindx,trigtemp) ! in :_aoslib:tsoar.f
            real*4 :: elev
            real*4 dimension(nl) :: p
            real*4 dimension(nl),depend(nl) :: z
            real*4 dimension(nl),depend(nl) :: t
            real*4 dimension(nl),depend(nl) :: theta
            integer*4, optional,check(len(p)>=nl),depend(p) :: nl=len(p)
            real*4 :: tpmax
            real*4 :: ptlxec
            real*4 :: zlnec
            real*4 :: tlnec
            real*4 :: zlxec
            real*4 :: tlxec
            real*4 :: soarindx
            real*4 :: trigtemp
        end subroutine tsoar
        subroutine calctv2(t,q,mni,ni,nj,tv) ! in calctv2.f
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: q
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj), intent(out) :: tv
        end subroutine calctv2
        subroutine gusts(p,t,td,np,gstpot) ! in :_aoslib:gusts.f
            real dimension(np) :: p
            real dimension(np),depend(np) :: t
            real dimension(np),depend(np) :: td
            integer, optional,check(len(p)>=np),depend(p) :: np=len(p)
            integer :: gstpot
        end subroutine gusts
        function ptozsa(p) ! in ptozsa.f
            real*4 intent(in) :: p
            real*4 intent(out) :: ptozsa
        end function ptozsa
        subroutine tv2temp(tv,q,mni,ni,nj,t) ! in tv2temp.f
            real dimension(mni,nj), intent(in) :: tv
            real dimension(mni,nj), intent(in)) :: q
            integer intent(hide), depend(tv) :: mni=shape(tv,0)
            integer optional, check(ni<=shape(tv,0)) :: ni=shape(tv,0)
            integer intent(hide), depend(tv) :: nj=shape(tv,1)
            real dimension(mni,nj), intent(out) :: t
        end subroutine tv2temp
        subroutine calctv(p,t,rh,mni,ni,nj,tv) ! in calctv.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: tv
        end subroutine calctv
        subroutine hailsiz(vvmax,hsize) ! in :_aoslib:hailsiz.f
            real :: vvmax
            real :: hsize
        end subroutine hailsiz
        subroutine pvadv(p_up,p_low,o_up,o_low,pva,pvort,mni,ni,nj,u_up,v_up,u_low,v_low,dx,dy,coriolis,u,v) ! in :_aoslib:pvadv.f
            real*4 dimension(mni,nj) :: p_up
            real*4 dimension(mni,nj),depend(mni,nj) :: p_low
            real :: o_up
            real :: o_low
            real*4 dimension(mni,nj),depend(mni,nj) :: pva
            real*4 dimension(mni,nj),depend(mni,nj) :: pvort
            integer, optional,check(shape(p_up,0)==mni),depend(p_up) :: mni=shape(p_up,0)
            integer :: ni
            integer, optional,check(shape(p_up,1)==nj),depend(p_up) :: nj=shape(p_up,1)
            real dimension(mni,nj),depend(mni,nj) :: u_up
            real dimension(mni,nj),depend(mni,nj) :: v_up
            real dimension(mni,nj),depend(mni,nj) :: u_low
            real dimension(mni,nj),depend(mni,nj) :: v_low
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: coriolis
            real dimension(mni,nj),depend(mni,nj) :: u
            real dimension(mni,nj),depend(mni,nj) :: v
        end subroutine pvadv
        subroutine uvcomp(dir,spd,u,v,nlvls) ! in :_aoslib:uvcomp.f
            real dimension(1) :: dir
            real dimension(1) :: spd
            real dimension(1) :: u
            real dimension(1) :: v
            integer :: nlvls
        end subroutine uvcomp
        subroutine calctw(p,t,rh,mni,ni,nj,tw) ! in calctw.f
            real dimension(mni,nj), intent(in) :: p
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            integer intent(hide), depend(p) :: mni=shape(p,0)
            integer optional, check(ni<=shape(p,0)) :: ni=shape(p,0)
            integer intent(hide), depend(p) :: nj=shape(p,1)
            real dimension(mni,nj), intent(out), depend(mni,nj) :: tw
        end subroutine calctw
        function mytw(k,kd,p) ! in :_aoslib:calctw.f
            real*4 :: k
            real*4 :: kd
            real*4 :: p
            real*4 :: mytw
        end function mytw
        subroutine calchelicity(hw,pw,uw,vw,nw,elev,ztop,ghx,ghy,diravg,spdavg,stmdir,stmspdkts,helicity,srhel) ! in :_aoslib:helicity.f
            real*4 dimension(nw) :: hw
            real*4 dimension(nw),depend(nw) :: pw
            real*4 dimension(nw),depend(nw) :: uw
            real*4 dimension(nw),depend(nw) :: vw
            integer, optional,check(len(hw)>=nw),depend(hw) :: nw=len(hw)
            real*4 :: elev
            real*4 :: ztop
            real*4 :: ghx
            real*4 :: ghy
            real*4 :: diravg
            real*4 :: spdavg
            real*4 :: stmdir
            real*4 :: stmspdkts
            real*4 :: helicity
            real*4 :: srhel
        end subroutine calchelicity
        subroutine pvalue(pres,p,np,param,value) ! in :_aoslib:pvalue.f
            real :: pres
            real dimension(1) :: p
            integer :: np
            real dimension(1) :: param
            real :: value
        end subroutine pvalue
        subroutine ver_pts(inp,count,init,mni,ni,nj) ! in :_aoslib:verpts.f
            real dimension(mni,nj) :: inp
            real dimension(mni,nj),depend(mni,nj) :: count
            integer :: init
            integer, optional,check(shape(inp,0)==mni),depend(inp) :: mni=shape(inp,0)
            integer :: ni
            integer, optional,check(shape(inp,1)==nj),depend(inp) :: nj=shape(inp,1)
        end subroutine ver_pts
        subroutine cclpar(mix,p,ht,t,nlvls,pccl,tccl,hccl) ! in cclpar.f
            real intent(in) :: mix
            real dimension(nlvls), intent(in) :: p
            real dimension(nlvls), intent(in) :: ht
            real dimension(nlvls), intent(in) :: t
            integer, intent(hide) :: nlvls=len(p)
            real intent(out) :: pccl
            real intent(out) :: tccl
            real intent(out) :: hccl
        end subroutine cclpar
        subroutine hgt2pres(z,p,mni,ni,nj) ! in hgt2pres.f
            real dimension(mni,nj), intent(in)  :: z
            real dimension(mni,nj), intent(out) :: p
            integer intent(hide), depend(z) :: mni=shape(z,0)
            integer optional, check(ni<=shape(z,0)) :: ni=shape(z,0)
            integer intent(hide), depend(z) :: nj=shape(z,1)
        end subroutine hgt2pres
        subroutine pvpres(t_up,t_low,p_up,p_low,pvort,mni,ni,nj,u_up,v_up,u_low,v_low,avort1,avort2,dtdx1,dtdy1,dtdx2,dtdy2,dx,dy,coriolis) ! in :_aoslib:pvpres.f
            real*4 dimension(mni,nj) :: t_up
            real*4 dimension(mni,nj),depend(mni,nj) :: t_low
            real dimension(mni,nj),depend(mni,nj) :: p_up
            real dimension(mni,nj),depend(mni,nj) :: p_low
            real*4 dimension(mni,nj),depend(mni,nj) :: pvort
            integer, optional,check(shape(t_up,0)==mni),depend(t_up) :: mni=shape(t_up,0)
            integer :: ni
            integer, optional,check(shape(t_up,1)==nj),depend(t_up) :: nj=shape(t_up,1)
            real dimension(mni,nj),depend(mni,nj) :: u_up
            real dimension(mni,nj),depend(mni,nj) :: v_up
            real dimension(mni,nj),depend(mni,nj) :: u_low
            real dimension(mni,nj),depend(mni,nj) :: v_low
            real dimension(mni,nj),depend(mni,nj) :: avort1
            real dimension(mni,nj),depend(mni,nj) :: avort2
            real dimension(mni,nj),depend(mni,nj) :: dtdx1
            real dimension(mni,nj),depend(mni,nj) :: dtdy1
            real dimension(mni,nj),depend(mni,nj) :: dtdx2
            real dimension(mni,nj),depend(mni,nj) :: dtdy2
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: coriolis
        end subroutine pvpres
        subroutine ver_range(inp,count,minval,maxval,mode,mni,ni,nj) ! in :_aoslib:verrange.f
            real dimension(mni,nj) :: inp
            real dimension(mni,nj),depend(mni,nj) :: count
            real dimension(mni,nj),depend(mni,nj) :: minval
            real dimension(mni,nj),depend(mni,nj) :: maxval
            integer :: mode
            integer, optional,check(shape(inp,0)==mni),depend(inp) :: mni=shape(inp,0)
            integer :: ni
            integer, optional,check(shape(inp,1)==nj),depend(inp) :: nj=shape(inp,1)
        end subroutine ver_range
        function cgp(tempip,dwptip,presip,thetawip,sfcpres,toppres,iw,deltap) ! in cgp.f
            real dimension(400), intent(in) :: tempip
            real dimension(400), intent(in) :: dwptip
            real dimension(400), intent(in) :: presip
            real dimension(400), intent(in) :: thetawip
            real intent(in) :: sfcpres
            real intent(in) :: toppres
            integer intent(in) :: iw
            real intent(in) :: deltap
            integer intent(out) :: cgp
        end function cgp
        function interp1(y1,y3,x1,x2,x3) ! in :_aoslib:interp1.f
            real :: y1
            real :: y3
            real :: x1
            real :: x2
            real :: x3
            real :: interp1
        end function interp1
        subroutine qdiverg(zmid,ztop,zbot,ptop,pbot,mni,ni,nj,dx,dy,f,w1,w2,w3,w4,w5,qx,qy,qdiv) ! in :_aoslib:qdiverg.f
            real dimension(mni,nj) :: zmid
            real dimension(mni,nj),depend(mni,nj) :: ztop
            real dimension(mni,nj),depend(mni,nj) :: zbot
            real :: ptop
            real :: pbot
            integer, optional,check(shape(zmid,0)==mni),depend(zmid) :: mni=shape(zmid,0)
            integer :: ni
            integer, optional,check(shape(zmid,1)==nj),depend(zmid) :: nj=shape(zmid,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: f
            real dimension(mni,nj),depend(mni,nj) :: w1
            real dimension(mni,nj),depend(mni,nj) :: w2
            real dimension(mni,nj),depend(mni,nj) :: w3
            real dimension(mni,nj),depend(mni,nj) :: w4
            real dimension(mni,nj),depend(mni,nj) :: w5
            real dimension(mni,nj),depend(mni,nj) :: qx
            real dimension(mni,nj),depend(mni,nj) :: qy
            real dimension(mni,nj),depend(mni,nj) :: qdiv
        end subroutine qdiverg
        function virttemp(t,td,p) ! in :_aoslib:virttemp.f
            real*4 :: t
            real*4 :: td
            real*4 :: p
            real*4 :: virttemp
        end function virttemp
        subroutine comp_by(u,v,uu,vv,mni,ni,nj,control,comp,comp2) ! in :_aoslib:comp_by.f
            real dimension(mni,nj) :: u
            real dimension(mni,nj),depend(mni,nj) :: v
            real dimension(mni,nj),depend(mni,nj) :: uu
            real dimension(mni,nj),depend(mni,nj) :: vv
            integer, optional,check(shape(u,0)==mni),depend(u) :: mni=shape(u,0)
            integer :: ni
            integer, optional,check(shape(u,1)==nj),depend(u) :: nj=shape(u,1)
            real :: control
            real dimension(mni,nj),depend(mni,nj) :: comp
            real dimension(mni,nj),depend(mni,nj) :: comp2
        end subroutine comp_by
        subroutine intpos(vdif,ht,p,t,nlvls) ! in :_aoslib:intpos.f
            real :: vdif
            real dimension(1) :: ht
            real dimension(1) :: p
            real dimension(1) :: t
            integer :: nlvls
        end subroutine intpos
        subroutine qvector(zmid,ztop,zbot,ptop,pbot,mni,ni,nj,dx,dy,f,dugdx,dvgdx,dugdy,dvgdy,dtdx,dtdy,qx,qy) ! in :_aoslib:qvector.f
            real dimension(mni,nj) :: zmid
            real dimension(mni,nj),depend(mni,nj) :: ztop
            real dimension(mni,nj),depend(mni,nj) :: zbot
            real :: ptop
            real :: pbot
            integer, optional,check(shape(zmid,0)==mni),depend(zmid) :: mni=shape(zmid,0)
            integer :: ni
            integer, optional,check(shape(zmid,1)==nj),depend(zmid) :: nj=shape(zmid,1)
            real dimension(mni,nj),depend(mni,nj) :: dx
            real dimension(mni,nj),depend(mni,nj) :: dy
            real dimension(mni,nj),depend(mni,nj) :: f
            real*4 dimension(mni,nj),depend(mni,nj) :: dugdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dvgdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dugdy
            real*4 dimension(mni,nj),depend(mni,nj) :: dvgdy
            real*4 dimension(mni,nj),depend(mni,nj) :: dtdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dtdy
            real dimension(mni,nj),depend(mni,nj) :: qx
            real dimension(mni,nj),depend(mni,nj) :: qy
            integer*4 :: passes
            real*4 :: smoothness
            common /qsmthcmn/ passes,smoothness
        end subroutine qvector
        subroutine virtualt(t,td,p,nlvls,tvir) ! in :_aoslib:virtualt.f
            real dimension(nlvls) :: t
            real dimension(nlvls),depend(nlvls) :: td
            real dimension(nlvls),depend(nlvls) :: p
            integer, optional,check(len(t)>=nlvls),depend(t) :: nlvls=len(t)
            real dimension(nlvls),depend(nlvls) :: tvir
        end subroutine virtualt
        subroutine constant(a,const_bn,mni,ni,nj) ! in :_aoslib:constant.f
            real dimension(mni,nj) :: a
            real :: const_bn
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine constant
        function b1_odd(arg) ! in :_aoslib:IntrinsicFunctions.f
            byte :: arg
            logical*2 :: b1_odd
        end function b1_odd
        function i4_odd(arg) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg
            logical*2 :: i4_odd
        end function i4_odd
        function bitest(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            logical*2 :: bitest
        end function bitest
        function jnint(arg) ! in :_aoslib:IntrinsicFunctions.f
            real :: arg
            integer*4 :: jnint
        end function jnint
        function jint(arg) ! in :_aoslib:IntrinsicFunctions.f
            real :: arg
            integer*4 :: jint
        end function jint
        function jmax0(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*4 :: jmax0
        end function jmax0
        function jmin0(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*4 :: jmin0
        end function jmin0
        function jisign(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*4 :: jisign
        end function jisign
        function jiabs(arg) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg
            integer*4 :: jiabs
        end function jiabs
        function iiand(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*2 :: iiand
        end function iiand
        function iishft(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*2 :: iishft
        end function iishft
        function iior(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*2 :: iior
        end function iior
        function imod(arg1,arg2) ! in :_aoslib:IntrinsicFunctions.f
            integer :: arg1
            integer :: arg2
            integer*2 :: imod
        end function imod
        subroutine radiation(lat,lng,lsm,jd,hr,bext,od,solrad) ! in :_aoslib:radiation.f
            real*4 :: lat
            real*4 :: lng
            real*4 :: lsm
            integer*4 :: jd
            integer*4 :: hr
            real*4 :: bext
            real*4 :: od
            real*4 :: solrad
        end subroutine radiation
        function vp(tk,iw) ! in :_aoslib:vp.f
            real :: tk
            integer :: iw
            real :: vp
        end function vp
        subroutine crossvectors(ax,ay,bx,by,result,mni,ni,nj) ! in :_aoslib:crossvectors.f
            real dimension(mni,nj), intent(in) :: ax
            real dimension(mni,nj), intent(in), depend(mni,nj) :: ay
            real dimension(mni,nj), intent(in), depend(mni,nj) :: bx
            real dimension(mni,nj), intent(in), depend(mni,nj) :: by
            real dimension(mni,nj), intent(out), depend(mni,nj) :: result
            integer, intent(hide), depend(ax) :: mni=shape(ax,0)
            integer optional, check(ni<=shape(ax,0)), depend(ax) :: ni=shape(ax,0)
            integer, intent(hide), depend(ax) :: nj=shape(ax,1)
        end subroutine crossvectors
        subroutine isen_stability(p_up,p_low,o_up,o_low,stab,mni,ni,nj) ! in :_aoslib:isenstable.f
            real*4 dimension(mni,nj) :: p_up
            real*4 dimension(mni,nj),depend(mni,nj) :: p_low
            real :: o_up
            real :: o_low
            real*4 dimension(mni,nj),depend(mni,nj) :: stab
            integer, optional,check(shape(p_up,0)==mni),depend(p_up) :: mni=shape(p_up,0)
            integer :: ni
            integer, optional,check(shape(p_up,1)==nj),depend(p_up) :: nj=shape(p_up,1)
        end subroutine isen_stability
        subroutine radrtns ! in :_aoslib:radrtns.f
            real*4 :: detrhz
            real*4 :: do_bn
            real*4 :: midhr
            real*4 :: hetrhz
            real*4 :: lat
            real*4 :: dec
            real :: deltim
            real :: hour
            real*4 :: hetrdn
            entry etravg(do_bn,lat,dec,hour,deltim,hetrhz,hetrdn)
            entry etrhrly(do_bn,lat,dec,midhr,hetrhz,hetrdn)
            entry etrday(lat,dec,do_bn,detrhz)
        end subroutine radrtns
        function sunset(lat,dec) ! in :_aoslib:radrtns.f
            real*4 :: lat
            real :: dec
            real :: sunset
        end function sunset
        subroutine vvel(pcb,peqlev,p,ht,tp,tve,tvp,wlcl,npar,vv,vvmax) ! in :_aoslib:vvel.f
            real :: pcb
            real :: peqlev
            real dimension(npar) :: p
            real dimension(npar),depend(npar) :: ht
            real dimension(npar),depend(npar) :: tp
            real dimension(npar),depend(npar) :: tve
            real dimension(npar),depend(npar) :: tvp
            real :: wlcl
            integer, optional,check(len(p)>=npar),depend(p) :: npar=len(p)
            real dimension(1) :: vv
            real :: vvmax
        end subroutine vvel
        subroutine ctop(p,ht,vv,peqlev,npar,cldtop) ! in :_aoslib:ctop.f
            real dimension(npar), intent(in) :: p
            real dimension(npar), intent(in), depend(npar) :: ht
            real dimension(npar), intent(in), depend(npar) :: vv
            real, intent(in) :: peqlev
            integer, optional, check(len(p)>=npar), depend(p) :: npar=len(p)
            real, intent(out) :: cldtop
        end subroutine ctop
        subroutine koffset(temp,mni,ni,nj,k0) ! in koffset.f
            real*4 dimension(mni,nj), intent(in) :: temp
            integer intent(hide), depend(temp) :: mni=shape(temp,0)
            integer optional, check(ni<=shape(temp,0)) :: ni=shape(temp,0)
            integer intent(hide), depend(temp) :: nj=shape(temp,1)
            real*4 intent(out) :: k0
        end subroutine koffset
        function rang2d(a,mnx,nx,ny,lo,hi) ! in :_aoslib:rang2d.f
            real*4 dimension(mnx,*) :: a
            integer*4, optional,check(shape(a,0)==mnx),depend(a) :: mnx=shape(a,0)
            integer*4 :: nx
            integer*4 :: ny
            real*4 :: lo
            real*4 :: hi
            real :: rang2d
        end function rang2d
        subroutine cv_date2jul(yr,mon,day,jd,istatus) ! in :_aoslib:cv_date2jul.f
            integer :: yr
            integer :: mon
            integer :: day
            integer*4 :: jd
            integer :: istatus
        end subroutine cv_date2jul
        subroutine lapserate(tlo,pzlo,thi,pzhi,vc,mnx,nx,ny,lapse) ! in :_aoslib:lapserate.f
            real*4 dimension(mnx,ny) :: tlo
            real*4 dimension(mnx,ny),depend(mnx,ny) :: pzlo
            real*4 dimension(mnx,ny),depend(mnx,ny) :: thi
            real*4 dimension(mnx,ny),depend(mnx,ny) :: pzhi
            integer*4 :: vc
            integer*4, optional,check(shape(tlo,0)==mnx),depend(tlo) :: mnx=shape(tlo,0)
            integer*4 :: nx
            integer*4, optional,check(shape(tlo,1)==ny),depend(tlo) :: ny=shape(tlo,1)
            real*4 dimension(mnx,ny),depend(mnx,ny) :: lapse
        end subroutine lapserate
        subroutine replinrange(a,testop,lo,hi,repl,result,mni,ni,nj) ! in :_aoslib:replinrange.f
            real dimension(mni,nj) :: a
            integer :: testop
            real dimension(mni,nj),depend(mni,nj) :: lo
            real dimension(mni,nj),depend(mni,nj) :: hi
            real dimension(mni,nj),depend(mni,nj) :: repl
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine replinrange
        subroutine winddir(u,v,ff,mni,ni,nj) ! in :_aoslib:winddir.f
            real dimension(mni,nj) :: u
            real dimension(mni,nj),depend(mni,nj) :: v
            real dimension(mni,nj),depend(mni,nj) :: ff
            integer, optional,check(shape(u,0)==mni),depend(u) :: mni=shape(u,0)
            integer :: ni
            integer, optional,check(shape(u,1)==nj),depend(u) :: nj=shape(u,1)
        end subroutine winddir
        subroutine cvgust(dd7,ui,gstpot) ! in :_aoslib:cvgust.f
            real :: dd7
            real :: ui
            integer :: gstpot
        end subroutine cvgust
        subroutine lclpar(meanmix,ts,p,ht,t,td,nlvls,plcl,tlcl,hlcl) ! in :_aoslib:lclpar.f
            real :: meanmix
            real :: ts
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: ht
            real dimension(nlvls),depend(nlvls) :: t
            real dimension(nlvls),depend(nlvls) :: td
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            real :: plcl
            real :: tlcl
            real :: hlcl
        end subroutine lclpar
        subroutine windspeed(u,v,ff,mni,ni,nj) ! in :_aoslib:windspeed.f
            real dimension(mni,nj) :: u
            real dimension(mni,nj),depend(mni,nj) :: v
            real dimension(mni,nj),depend(mni,nj) :: ff
            integer, optional,check(shape(u,0)==mni),depend(u) :: mni=shape(u,0)
            integer :: ni
            integer, optional,check(shape(u,1)==nj),depend(u) :: nj=shape(u,1)
        end subroutine windspeed
        subroutine ddff(u,v,dir,spd,nlvls) ! in :_aoslib:ddff.f
            real dimension(1) :: u
            real dimension(1) :: v
            real dimension(1) :: dir
            real dimension(1) :: spd
            integer :: nlvls
        end subroutine ddff
        subroutine lfcpar(eptpar,pcb,tcb,hcb,t1,t2,p1,ht1,npar,plfc1,hlfc1,tlfc1,plfc2,hlfc2,tlfc2) ! in :_aoslib:lfcpar.f
            real :: eptpar
            real :: pcb
            real :: tcb
            real :: hcb
            real dimension(npar) :: t1
            real dimension(npar),depend(npar) :: t2
            real dimension(npar),depend(npar) :: p1
            real dimension(npar),depend(npar) :: ht1
            integer, optional,check(len(t1)>=npar),depend(t1) :: npar=len(t1)
            real :: plfc1
            real :: hlfc1
            real :: tlfc1
            real :: plfc2
            real :: hlfc2
            real :: tlfc2
        end subroutine lfcpar
        subroutine rotvectors(ax,ay,angle,bx,by,mni,ni,nj) ! in :_aoslib:rotvectors.f
            real dimension(mni,nj) :: ax
            real dimension(mni,nj),depend(mni,nj) :: ay
            real :: angle
            real dimension(mni,nj),depend(mni,nj) :: bx
            real dimension(mni,nj),depend(mni,nj) :: by
            integer, optional,check(shape(ax,0)==mni),depend(ax) :: mni=shape(ax,0)
            integer :: ni
            integer, optional,check(shape(ax,1)==nj),depend(ax) :: nj=shape(ax,1)
        end subroutine rotvectors
        subroutine wndrho(rho,ht,nlvls,hw,nw,rhow) ! in :_aoslib:wndrho.f
            real dimension(1) :: rho
            real dimension(1) :: ht
            integer :: nlvls
            real dimension(1) :: hw
            integer :: nw
            real dimension(1) :: rhow
        end subroutine wndrho
        subroutine deftrk(tcb,pcb,thdpar,eptpar) ! in :_aoslib:deftrk.f
            real :: tcb
            real :: pcb
            real :: thdpar
            real :: eptpar
        end subroutine deftrk
        subroutine liftedp(p,t,ht,tvir,nlvls,npar,pcb,hcb,tcb,wcb,thdpar,eptpar,pl,tl,pp,htp,tp,tvirp,te,tvire,nparcel) ! in :_aoslib:liftedp.f
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: t
            real dimension(nlvls),depend(nlvls) :: ht
            real dimension(nlvls),depend(nlvls) :: tvir
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            integer, optional,check(len(pp)>=npar),depend(pp) :: npar=len(pp)
            real :: pcb
            real :: hcb
            real :: tcb
            real :: wcb
            real :: thdpar
            real :: eptpar
            real :: pl
            real :: tl
            real dimension(npar) :: pp
            real dimension(npar),depend(npar) :: htp
            real dimension(npar),depend(npar) :: tp
            real dimension(npar),depend(npar) :: tvirp
            real dimension(npar),depend(npar) :: te
            real dimension(npar),depend(npar) :: tvire
            integer :: nparcel
        end subroutine liftedp
        subroutine setqsmooth(npass,smthwgt) ! in :_aoslib:setqsmooth.f
            integer*4 :: npass
            real*4 :: smthwgt
            integer*4, optional :: passes=0
            real*4, optional :: smoothness=0.5
            common /qsmthcmn/ passes,smoothness
        end subroutine setqsmooth
        function ztopsa(z) ! in ztopsa.f
            real*4 intent(in) :: z
            real*4 intent(out) :: ztopsa
        end function ztopsa
        subroutine density(p,tvir,nlvls,rho) ! in :_aoslib:density.f
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: tvir
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            real dimension(nlvls),depend(nlvls) :: rho
        end subroutine density
        subroutine lintrans(a,mult,add,result,mni,ni,nj) ! in :_aoslib:lintrans.f
            real dimension(mni,nj) :: a
            real :: mult
            real :: add
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
        end subroutine lintrans
        subroutine slfront(z,t,p,dx,dy,coriolis,mni,ni,nj,fgen,slqx,slqy,w1,w2,w3,dtdx,dtdy) ! in :_aoslib:slfront.f
            real*4 dimension(mni,nj), intent(in) :: z
            real*4 dimension(mni,nj), intent(in) :: t
            real intent(in) :: p
            real*4 dimension(mni,nj), intent(in) :: dx
            real*4 dimension(mni,nj), intent(in) :: dy
            real*4 dimension(mni,nj), intent(in) :: coriolis
            integer intent(hide), depend(z) :: mni=shape(z,0)
            integer optional, check(ni<=shape(z,0)) :: ni=shape(z,0)
            integer intent(hide), depend(z) :: nj=shape(z,1)
            real*4 dimension(mni,nj), intent(out) :: fgen
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: slqx
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: slqy
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: w1
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: w2
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: w3
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: dtdx
            real*4 dimension(mni,nj), intent(hide), depend(mni,nj) :: dtdy
        end subroutine slfront
        subroutine derivative(a1,a2,b1,b2,result,mni,ni,nj) ! in :_aoslib:derivative.f
            real dimension(mni,nj) :: a1
            real dimension(mni,nj),depend(mni,nj) :: a2
            real dimension(mni,nj),depend(mni,nj) :: b1
            real dimension(mni,nj),depend(mni,nj) :: b2
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a1,0)==mni),depend(a1) :: mni=shape(a1,0)
            integer :: ni
            integer, optional,check(shape(a1,1)==nj),depend(a1) :: nj=shape(a1,1)
        end subroutine derivative
        subroutine matsln(a,v,p,s,mn,n,status) ! in :_aoslib:matsln.f
            real*4 dimension(mn + 1,mn + 1) :: a
            real*4 dimension(mn + 1),depend(mn) :: v
            integer*4 dimension(mn + 1),depend(mn) :: p
            real*4 dimension(mn + 1),depend(mn) :: s
            integer*4, optional,check((shape(a,0)-1)==mn),depend(a) :: mn=(shape(a,0)-1)
            integer*4 :: n
            integer*4 :: status
        end subroutine matsln
        subroutine slqdiv(z,t,p,dx,dy,coriolis,mni,ni,nj,slqd,slqx,slqy,w1,w2,w3,w4,w5) ! in :_aoslib:slqdiv.f
            real*4 dimension(mni,nj) :: z
            real*4 dimension(mni,nj),depend(mni,nj) :: t
            real :: p
            real*4 dimension(mni,nj),depend(mni,nj) :: dx
            real*4 dimension(mni,nj),depend(mni,nj) :: dy
            real*4 dimension(mni,nj),depend(mni,nj) :: coriolis
            integer, optional,check(shape(z,0)==mni),depend(z) :: mni=shape(z,0)
            integer :: ni
            integer, optional,check(shape(z,1)==nj),depend(z) :: nj=shape(z,1)
            real*4 dimension(mni,nj),depend(mni,nj) :: slqd
            real*4 dimension(mni,nj),depend(mni,nj) :: slqx
            real*4 dimension(mni,nj),depend(mni,nj) :: slqy
            real*4 dimension(mni,nj),depend(mni,nj) :: w1
            real*4 dimension(mni,nj),depend(mni,nj) :: w2
            real*4 dimension(mni,nj),depend(mni,nj) :: w3
            real*4 dimension(mni,nj),depend(mni,nj) :: w4
            real*4 dimension(mni,nj),depend(mni,nj) :: w5
        end subroutine slqdiv
        subroutine derived_icing(t,rh,icg,mni,ni,nj) ! in derived_icing.f
            real dimension(mni,nj), intent(in) :: t
            real dimension(mni,nj), intent(in) :: rh
            real dimension(mni,nj), intent(out) :: icg
            integer intent(hide), depend(t) :: mni=shape(t,0)
            integer optional, check(ni<=shape(t,0)) :: ni=shape(t,0)
            integer intent(hide), depend(t) :: nj=shape(t,1)
        end subroutine derived_icing
        subroutine max_min(a,b,result,mni,ni,nj,mode) ! in :_aoslib:maxmin.f
            real dimension(mni,nj) :: a
            real dimension(mni,nj),depend(mni,nj) :: b
            real dimension(mni,nj),depend(mni,nj) :: result
            integer, optional,check(shape(a,0)==mni),depend(a) :: mni=shape(a,0)
            integer :: ni
            integer, optional,check(shape(a,1)==nj),depend(a) :: nj=shape(a,1)
            integer :: mode
        end subroutine max_min
        subroutine slqvect(z,t,p,dx,dy,coriolis,mni,ni,nj,slqx,slqy,dugdx,dugdy,dvgdx,dvgdy,dtdx,dtdy) ! in :_aoslib:slqvect.f
            real*4 dimension(mni,nj) :: z
            real*4 dimension(mni,nj),depend(mni,nj) :: t
            real :: p
            real*4 dimension(mni,nj),depend(mni,nj) :: dx
            real*4 dimension(mni,nj),depend(mni,nj) :: dy
            real*4 dimension(mni,nj),depend(mni,nj) :: coriolis
            integer, optional,check(shape(z,0)==mni),depend(z) :: mni=shape(z,0)
            integer :: ni
            integer, optional,check(shape(z,1)==nj),depend(z) :: nj=shape(z,1)
            real*4 dimension(mni,nj),depend(mni,nj) :: slqx
            real*4 dimension(mni,nj),depend(mni,nj) :: slqy
            real*4 dimension(mni,nj),depend(mni,nj) :: dugdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dugdy
            real*4 dimension(mni,nj),depend(mni,nj) :: dvgdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dvgdy
            real*4 dimension(mni,nj),depend(mni,nj) :: dtdx
            real*4 dimension(mni,nj),depend(mni,nj) :: dtdy
            integer*4 :: passes
            real*4 :: smoothness
            common /qsmthcmn/ passes,smoothness
        end subroutine slqvect

! --- Manual Additions    
        subroutine forecast(yr,mon,day,hr,min_bn,stnid,snow,slat,slon,p,ht,t,td,nlvls,ftmax,status) ! in :aoslib:forecast.f
            integer :: yr
            integer :: mon
            integer :: day
            integer :: hr
            integer :: min_bn
            character*4 :: stnid
            integer :: snow
            real :: slat
            real :: slon
            real dimension(nlvls) :: p
            real dimension(nlvls),depend(nlvls) :: ht
            real dimension(nlvls),depend(nlvls) :: t
            real dimension(nlvls),depend(nlvls) :: td
            integer, optional,check(len(p)>=nlvls),depend(p) :: nlvls=len(p)
            real :: ftmax
            integer :: status
        end subroutine forecast
        subroutine mxtp(ansol,deltap,sfcp,p2,tl,deltaz,lvl,ctmax) ! in :aoslib:mxtp.f
            real :: ansol
            real :: deltap
            real :: sfcp
            real :: p2
            real dimension(*) :: tl
            real dimension(*) :: deltaz
            integer :: lvl
            real :: ctmax
        end subroutine mxtp
        subroutine rhbar(endlvl,mrh,nclyr,sfcp,p,tl,tdl) ! in :aoslib:rhbar.f
            real dimension(*) :: endlvl
            integer dimension(*) :: mrh
            integer :: nclyr
            real :: sfcp
            real dimension(*) :: p
            real dimension(*) :: tl
            real dimension(*) :: tdl
        end subroutine rhbar
        subroutine solax(julday,month,slat,tyminc,tstart,tstop,tsrad) ! in :aoslib:solax.f
            integer*2 :: julday
            integer*2 :: month
            real*4 :: slat
            integer*2 :: tyminc
            integer*2 :: tstart
            integer*2 :: tstop
            real*4 :: tsrad
        end subroutine solax
! -- END MANUAL ADDITIONS

    end interface 
end python module _awips

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
